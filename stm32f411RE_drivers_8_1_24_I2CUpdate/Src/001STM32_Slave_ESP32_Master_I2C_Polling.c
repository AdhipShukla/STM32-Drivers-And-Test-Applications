/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f411re.h"
#include <string.h>
#include <stdio.h>
#define MasterExample	1
#define MY_ADDR 	0x61
#define SLAVE_ADDR 	0x3E
#define PRESSED 	1
uint8_t Message[] = "I2C Occupy Mars!\n";
uint8_t RecByte;
I2C_Handle_t I2C1Handle;
void delay(void){
	for(uint32_t i=0; i<500000; i++);
}

int main(void)
{

	//GPIO Button for message sending
	GPIO_Handle_t GPIOButton;
	GPIOButton.pGPIOx= GPIOC;
	GPIOButton.GPIO_Config.GPIO_PinNumber=GPIO_PIN_NUM_13;
	GPIOButton.GPIO_Config.GPIO_PinMode=GPIO_MODE_IN;
	GPIOButton.GPIO_Config.GPIO_PinOPType=GPIO_OP_TYPES_PP;
	GPIOButton.GPIO_Config.GPIO_PinSpeed=GPIO_OP_SPEED_FAST;
	GPIOButton.GPIO_Config.GPIO_PinPuPdControl=GPIO_NO_PUPD;
	GPIO_PeriClockControl(GPIOC, ENABLE);
	GPIO_Init(&GPIOButton);

	//LED
	GPIO_Handle_t InternalLED;
	InternalLED.pGPIOx= GPIOA;
	InternalLED.GPIO_Config.GPIO_PinNumber=GPIO_PIN_NUM_5;
	InternalLED.GPIO_Config.GPIO_PinMode=GPIO_MODE_OUT;
	InternalLED.GPIO_Config.GPIO_PinOPType=GPIO_OP_TYPES_PP;
	InternalLED.GPIO_Config.GPIO_PinSpeed=GPIO_OP_SPEED_FAST;
	InternalLED.GPIO_Config.GPIO_PinPuPdControl=GPIO_NO_PUPD;
	GPIO_PeriClockControl(GPIOA, ENABLE);
	GPIO_Init(&InternalLED);

	//GPIO INIT FOR I2C
	//PB8 - I2C1_SCL
	//PB9 - I2C1_SDA
	GPIO_Handle_t I2CPins;
	I2CPins.pGPIOx = GPIOB;
	I2CPins.GPIO_Config.GPIO_PinMode = GPIO_MODE_ALTFN;
	I2CPins.GPIO_Config.GPIO_PinAltFunMode = 4;
	I2CPins.GPIO_Config.GPIO_PinOPType = GPIO_OP_TYPES_OD;
	I2CPins.GPIO_Config.GPIO_PinPuPdControl = GPIO_NO_PUPD;
	I2CPins.GPIO_Config.GPIO_PinSpeed = GPIO_OP_SPEED_FAST;

	I2CPins.GPIO_Config.GPIO_PinNumber = 8; //I2C1_SCL
	GPIO_Init(&I2CPins);

	I2CPins.GPIO_Config.GPIO_PinNumber = 9; //I2C1_SDA
	GPIO_Init(&I2CPins);

	//I2CInit
	I2C1Handle.pI2Cx = I2C1;
	I2C1Handle.I2C_Config.I2C_ACKControl = I2C_ACK_ENABLE;
	I2C1Handle.I2C_Config.I2C_DeviceAddress = MY_ADDR;	//Self address does not matter as master mode
	I2C1Handle.I2C_Config.I2C_FMDutyCycle =  I2C_FM_DUTY_2; //Does not matter as it is in standard mode
	I2C1Handle.I2C_Config.I2C_SCLSpeed = I2C_SCL_SPEED_SM;  //Standard mode i.e. 100k speed
	I2C_Init(&I2C1Handle);
	//Enable peripheral
	I2C_PeripheralControl(I2C1, ENABLE);
	I2C_AckSet(&I2C1Handle, I2C1Handle.I2C_Config.I2C_ACKControl);
	for(;;){
		if(MasterExample){
			while(GPIO_ReadFromInputPin(GPIOC, GPIO_PIN_NUM_13)==PRESSED); //Wait for button to press
			//Eliminate debouncing
			delay();
			//Send Data
			I2C_MasterSendData(&I2C1Handle, Message, strlen((char *)Message), SLAVE_ADDR, I2C_SR_DISABLE);
			}
		else{
			if(I2C1Handle.pI2Cx->I2C_SR2 & (1<<I2C_SR2_TRA))
				I2C_SlaveSendData(&I2C1Handle, Message, strlen((char *)Message), SLAVE_ADDR, I2C_SR_DISABLE);
			else
				I2C_SlaveReceiveData(&I2C1Handle, &RecByte, 1);
		}
		if(RecByte%5==0){
			GPIO_ToggleOutputPin(GPIOA, GPIO_PIN_NUM_5);
		}
	}
}
